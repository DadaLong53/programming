Ruby原理剖析
　作　　者：	(美)帕特里克‧肖內西
　出版單位：	華中科技大學
　出版日期：	2016.10
　ＩＳＢＮ：	9787568022620
 
 《Ruby原理剖析》解開Ruby編程語言的魔法面紗。全書圖文並茂、深入淺出地剖析了Ruby編程語言的核心工作原理。
 作者本著科學實證的精神，設計了一系列實驗，幫助讀者輕鬆瞭解這門編程語言的工作奧秘，包括Ruby如何用虛擬機執行代碼，
 Ruby的垃圾回收演算法，以及類和模組在Ruby內部的關係等。

作者簡介：
Patrick Shaughnessy是著名的Ruby開發者，目前在麥肯錫管理諮詢公司（McKinsey & Co.）從事開發工作。
Patrick有20多年軟體開發工作經驗，精通C、Java、PHP、Ruby等多種編程語言。他是Ruby Conference Circuit的主持人，
定期在Ruby Weekly電子報、Ruby5 Podcast和The Ruby Show上發表文章和演講。

圖書目錄：
1 分詞與語法解析 3 

1.1 詞條：構成Ruby語言的單詞 5 

1.2 語法解析：Ruby如何理解代碼 13 

1.2.1 理解LALR解析演算法 14 

1.2.2 真實的Ruby語法規則 21 

1.3 總結 31 

2 編譯 33 

2.1 Ruby 1.8沒有編譯器 34 

2.2 Ruby 1.9和Ruby 2.0引入了編譯器 35 

2.3 Ruby如何編譯簡單腳本 37 

2.4 編譯塊調用 41 

2.5 本地表 49 

2.5.1 編譯可選參數 52 

2.5.2 編譯關鍵字參數 53 

2.6 總結 57 

3 Ruby如何執行代碼 59 

3.1 YARV內部棧和Ruby調用棧 60 

3.1.1 逐句查看Ruby如何執行簡單腳本 62 

3.1.2 執行塊調用 65 

3.2 訪問Ruby變數的兩種方式 72 

3.2.1 本地變數訪問 72 

3.2.2 方法參數被看成本地變數 75 

3.2.3 動態變數訪問 76 

3.3 總結 86 

4 控制結構與方法調度 89 

4.1 Ruby如何執行if語句 90 

4.2 作用域之間的跳轉 93 

4.2.1 捕獲表 94 

4.2.2 捕獲表的其他用途 96 

4.3 send指令：Ruby最複雜的控制結構 99 

4.3.1 方法查找和方法調度 99 

4.3.2 Ruby方法的11種類型 100 

4.4 調用普通Ruby方法 102 

4.4.1 為普通Ruby方法準備參數 103 

4.5 調用內建的Ruby方法 104 

4.5.1 調用attr_reader和attr_writer 105 

4.5.2 方法調度優化attr_reader和attr_writer 106 

4.6 總結 110 

5 對象與類 113 

5.1 Ruby對象內部 114 

5.1.1 檢驗klass和ivptr 115 

5.1.2 觀察同一個類的兩個實例 117 

5.1.3 基本類型對象 118 

5.1.4 簡單立即值完全不需要結構體 119 

5.1.5 基本類型對象有實例變數嗎 120 

5.1.6 基本類型對象的實例變數保存在哪里 122 

5.2 RClass結構體內部有什麼 125 

5.2.1 繼承 128 

5.2.2 類實例變數vs類變數 129 

5.2.3 存取類變數 131 

5.2.4 常量 134 

5.2.5 真實的RClass結構體 135 

5.3 總結 140 

6 方法查找和常量查找 143 

6.1 Ruby如何實現模組 145 

6.1.1 模組是類 145 

6.1.2 將模組include到類中 147 

6.2 Ruby的方法查找演算法 148 

6.2.1 方法查找示例 149 

6.2.2 方法查找演算法實踐 151 

6.2.3 Ruby中的多繼承 152 

6.2.4 全局方法緩存 153 

6.2.5 內聯方法緩存 154 

6.2.6 清空Ruby的方法緩存 155 

6.2.7 在同一個類中include兩個模組 155 

6.2.8 在模組中include模組 157 

6.2.9 Module#prepend 示例 158 

6.2.10 Ruby如何實現Module#prepend 161 

6.2.11 在已被include的模組中增加方法 164 

6.2.12 在已被include的模組中include其他模組 164 

6.2.13 “被include的類”與原始模組共用方法表 166 

6.3 常量查找 168 

6.3.1 在超類中查找常量 169 

6.3.2 Ruby如何在父級命名空間中查找常量 170 

6.4 Ruby中的詞法作用域 171 

6.4.1 為新類或模組創建常量 172 

6.4.2 在父命名空間中使用詞法作用域查找常量 173 

6.4.3 Ruby的常量查找演算法 175 

6.4.4 Ruby真實的常量查找演算法 177 

6.5 總結 178 

7 散列表：Ruby內部的主力軍 181 

7.1 Ruby中的散列表 182 

7.1.1 在散列表中保存值 183 

7.1.2 從散列表中檢索值 185 

7.2 散列表如何擴展以容納更多的值 188 

7.2.1 散列衝突 188 

7.2.2 重新散列條目 189 

7.3 Ruby如何實現散列函數 195 

7.3.1 Ruby 2.0中的散列優化 202 

7.4 總結 203 

8 Ruby如何借鑒Lisp幾十年前的理念 207 

8.1 塊: Ruby中的閉包 208 

8.1.1 Ruby如何調用塊 210 

8.1.2 借用1975年的理念 212 

8.2 Lambda和Proc：把函數當做一等公民 219 

8.2.1 棧記憶體vs堆記憶體 220 

8.2.2 深入探索Ruby如何保存字串的值 220 

8.2.3 Ruby如何創建Lambda 223 

8.2.4 Ruby如何調用Lambda 226 

8.2.5 Proc對象 227 

8.2.6 在同一個作用域中多次調用lambda 232 

8.3 總結 234 

9 元編程 237 

9.1 定義方法的多種方式 239 

9.1.1 Ruby的普通方法定義過程 239 

9.1.2 使用對象首碼定義類方法 241 

9.1.3 使用新的詞法作用域定義類方法 242 

9.1.4 使用單類定義方法 244 

9.1.5 在單類的詞法作用域中定義方法 245 

9.1.6 創建Refinement 246 

9.1.7 使用Refinement 248 

9.1.8 頂級作用域中的self 250 

9.1.9 類作用域中的self 251 

9.1.10 元類作用域中的self 252 

9.1.11 類方法中的self 253 

9.2 元編程與閉包：eval、instance_eval和binding 255 

9.2.1 能寫代碼的代碼 255 

9.2.2 使用binding參數調用eval 257 

9.2.3 instance_eval示例 259 

9.2.4 Ruby閉包的另一個重點 260 

9.2.5 instance_eval改變接收者的self 262 

9.2.6 instance_eval為新的詞法作用域創建單類 262 

9.2.7 使用define_method 266 

9.2.8 充當閉包的方法 266 

9.3 總結 268 

10 JRuby：基於JVM的Ruby 271 

10.1 使用MRI和JRuby運行程式 272 

10.1.1 JRuby如何解析和編譯代碼 274 

10.1.2 JRuby如何執行代碼 276 

10.1.3 用Java類實現Ruby類 278 

10.1.4 使用-J-XX: PrintCompilation選項 281 

10.1.5 JIT是否提升了JRuby程式的性能 283 

10.2 JRuby和MRI中的字串 284 

10.2.1 JRuby和MRI如何保存字串數據 284 

10.2.2 寫時複製 286 

10.2.3 創建唯一且非共用的字串 288 

10.2.4 可視化寫時複製 290 

10.2.5 修改共用字串更慢 291 

10.3 總結 293 

11 Rubinius：用Ruby實現的Ruby 295 

11.1 Rubinius內核和虛擬機 296 

11.1.1 詞法分析和解析 298 

11.1.2 使用Ruby編譯Ruby 299 

11.1.3 Rubinius位元組碼指令 300 

11.1.4 Ruby和C 一起工作 302 

11.1.5 使用C 對象實現Ruby對象 303 

11.1.6 Rubinius中的（棧）回溯 305 

11.2 Rubinius和MRI中的數組 307 

11.2.1 MRI中的數組 307 

11.2.2 Rubinius中的數組 309 

11.2.3 閱讀Array#shift源碼 311 

11.2.4 修改Array#shift方法 312 

11.3 總結 315 

12 MRI、JRuby、Rubinius垃圾回收 317 

12.1 垃圾回收器解決三個問題 319 

12.2 MRI中的垃圾回收: 標記與清除 320 

12.2.1 空閒列表 320 

12.2.2 標記 321 

12.2.3 MRI如何標記存活對象 323 

12.2.4 清除 323 

12.2.5 延遲清除 324 

12.2.6 標記-清除的缺點 325 

12.2.7 觀察MRI執行延遲清除 327 

12.2.8 觀察MRI執行全回收 328 

12.2.9 解讀GC分析報告 329 

12.3 JRuby和Rubinius中的垃圾回收 332 

12.4 複製垃圾回收 333 

12.4.1 碰撞分配 333 

12.4.2 半空間演算法 334 

12.4.3 伊甸堆 336 

12.5 分代垃圾回收 337 

12.5.1 弱代假說 337 

12.5.2 為新生代使用半空間演算法 338 

12.5.3 晉升對象 338 

12.5.4 成熟代對象垃圾回收 339 
12.6 併發垃圾回收 341 
12.6.1 當對象圖改變時進行標記 341 
12.6.2 三色標記 343 
12.6.3 JVM中的三種垃圾收集器 344 
12.6.4 觸發主收集 347 
12.7 延伸閱讀 348 
12.8 總結 349 
